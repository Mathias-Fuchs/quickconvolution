#include "staticHelpers.h"
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <GLFW/glfw3.h>
#include <stdbool.h>
#include "box.h"


int hold = 0;
static int xTextureCorrection = 0.f;// 121;
static int yTextureCorrection = 0.f;// -128;
const static float zTextureCorrection = 0.4; // 0.4f;// 0.16f;
static float bwCorrection = 0.f;
bool _bwChanged = false;
static int isolines = 0;

bool _3d = false;


#ifdef USESHADER
static int programID;
#endif

#define MIN(a, b) (a > b ? b : a)
#define MAX(a, b) (a > b ? a : b)
#define CLAMP(v, lo, hi) MAX(lo, MIN(hi, v))


static inline void minmaxF(float *b, int l, float* min, float* max)
{
	float m = b[0];
	float mm = b[0];
	for (int x = 0; x < l; x++)
	{
		if (m > b[x]) m = b[x];
		if (mm < b[x]) mm = b[x];
	}
	*min = m;
	*max = mm;
}

static inline void Zebra(float ints, float*r) {
	*r = (float)(((int)(5.f * ints)) % 2);
}

static inline float LinearStep(float x, float start)
{
	float width = 0.2f;
	if (x < start)
		return 0.0f;
	else if (x > start + width)
		return 1;
	else
		return (x - start) / width;
}

static inline float GetRedValue(float intensity)
{
	return intensity * intensity * intensity;
}

static inline float GetGreenValue(float intensity)
{
	return intensity * intensity;
	//	return LinearStep(intensity, 0.6f);
}

static inline float GetBlueValue(float intensity)
{
	return  intensity;
	//	return LinearStep(intensity, 0.0f) - LinearStep(intensity, 0.4f) + LinearStep(intensity, 0.8f);
}

void error_callback(int error, const char *description)
{
	fputs(description, stderr);
}

void key_callback(GLFWwindow *window, int key, int scancode, int action, int mods)
{

	if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
		glfwSetWindowShouldClose(window, GL_TRUE);

	if (key == GLFW_KEY_SPACE && action == GLFW_PRESS)
		hold = 1;

	if (key == GLFW_KEY_SPACE && action == GLFW_RELEASE)
		hold = 0;

	if (key == GLFW_KEY_LEFT && action == GLFW_PRESS)
		xTextureCorrection += 1;

	if (key == GLFW_KEY_RIGHT && action == GLFW_PRESS)
		xTextureCorrection -= 1;

	if (key == GLFW_KEY_UP && action == GLFW_PRESS)
		yTextureCorrection -= 1;

	if (key == GLFW_KEY_DOWN && action == GLFW_PRESS)
		yTextureCorrection += 1;

	if (key == GLFW_KEY_W && action == GLFW_PRESS) {
		// zTextureCorrection += .01f;
		fprintf(stdout, "z correction %f \n", zTextureCorrection);
	}

	if (key == GLFW_KEY_S && action == GLFW_PRESS) {
		// zTextureCorrection -= .01f;
		fprintf(stdout, "z correction %f \n", zTextureCorrection);
	}
	if (key == GLFW_KEY_M && action == GLFW_REPEAT) {

		bwCorrection -= .015f;
		_bwChanged = true;
	}
	if (key == GLFW_KEY_J && action == GLFW_REPEAT) {
		bwCorrection += .015f;
		_bwChanged = true;
	}
	if (key == GLFW_KEY_I && action == GLFW_PRESS) {
		isolines = 1 - isolines;
	}

}

float getBwCorrection() {
	return bwCorrection;
}

bool bwChanged() {
	return _bwChanged;
}

void bwAdjusted() {
	_bwChanged = false;
}

int* triangle(int n) {

	// generate the triangle sequence
	int cols = n;
	int rows = n;
	int RCvertices = 2 * cols * (rows - 1);
	int TSvertices = 2 * cols * (rows - 1) + 2 * (rows - 2);
	int numVertices = TSvertices;
	int j = 0;
	int i;
	int *trianglestrip = malloc(sizeof(int) * numVertices);

	for (i = 1; i <= RCvertices; i += 2)
	{
		trianglestrip[j] = (1 + i) / 2;
		trianglestrip[j + 1] = (cols * 2 + i + 1) / 2;
		if (trianglestrip[j + 1] % cols == 0)
		{
			if (trianglestrip[j + 1] != cols && trianglestrip[j + 1] != cols * rows)
			{
				trianglestrip[j + 2] = trianglestrip[j + 1];
				trianglestrip[j + 3] = (1 + i + 2) / 2;
				j += 2;
			}
		}
		j += 2;
	}
	return trianglestrip;
}


void drawTextureNoClip(int *trianglestrip, float** A, const int* n, int blend) {
	float minA, maxA;

	// just to find out how many vertices there are
	int cols = *n;
	int rows = *n;
	// int RCvertices = 2 * cols * (rows - 1);
	int TSvertices = 2 * cols * (rows - 1) + 2 * (rows - 2);
	int numVertices = TSvertices;
	minmaxF(*A, *n * *n, &minA, &maxA);

	if (minA == maxA)
		return;

	if (blend != 0) {
		// This fixes the overlap issue
		glDisable(GL_DEPTH_TEST);

		// Turn on the blend mode
		glEnable(GL_BLEND);

		// Define the blend mode
		glBlendFunc(GL_SRC_ALPHA, GL_ONE);
	}
	else {
		glEnable(GL_DEPTH_TEST);
	}

	glBegin(GL_TRIANGLE_STRIP);
	for (int j = 0; j < numVertices; j++)
	{
		// a number between 0 and n^2 - 1
		int vertexToDraw = trianglestrip[j] - 1;

		//betwenn 0 and n-1
		int jj = (vertexToDraw) % (*n);
		//between 0 and n-1
		int ii = (vertexToDraw - 1 - jj) / (*n);

		// the actual value to be plotted

		float intensity = (*A)[jj + *n * ii];
		float ints = (intensity - minA) / (maxA - minA);

		if (isolines != 0) {
			float r;
			Zebra(ints, &r);
			glColor3f(r, r, r);
		}
		else {
			float red = GetRedValue(ints);
			float green = GetGreenValue(ints);
			float blue = GetBlueValue(ints);
			glColor3f(red, green, blue);
		}

		float glx, gly;
		box_texture_gl(*n, ii, jj, &glx, &gly);
		glVertex3f(gly, glx, zTextureCorrection);
	}
	glEnd();
	return;
}

void drawVertices0(box* bglBox, float* allV, int nVert) {
	glBegin(GL_POINTS);
	glColor3f(1.0f, 1.0f, 1.0f);
	for (int i = 0; i < nVert; i++)
	{
		float x, y, z;
		box_world_gl(bglBox, allV[0 + 3 * i], allV[1 + 3 * i], allV[2 + 3 * i], &x, &y, &z);
		glVertex3f(y, x, -1.f - z); // y first
	}
	glEnd();
}

void markPoint(box* b, float x, float y) {
	glBegin(GL_POINTS);
	glColor3f(1.0f, 0.0f, 0.0f);
	float glx, gly, glz;
	box_world_gl(b, x, y, 0.f, &glx, &gly, &glz);
	glVertex3f(gly, glx, zTextureCorrection); // y first
	glEnd();
}




float mean(float* array, int n) {
	/* // to be replaced with moving average calculation */
	float sum = 0.f;
	for (int loop = 0; loop < n; loop++) sum += array[loop];
	return (float)sum / n;
}

int positive_modulo(int i, int n) {
	return (i % n + n) % n;
}

void setupGl(
	GLFWwindow** window,
	int width,
	int height,
	float alpha,
	char* title) {


	glfwSetErrorCallback(error_callback);
	if (!glfwInit())
		exit(EXIT_FAILURE);
	*window = glfwCreateWindow(width, height, title, NULL, NULL);
	if (!(*window))
	{
		glfwTerminate();
		exit(EXIT_FAILURE);
	}
	glfwMakeContextCurrent(*window);
	glfwSetKeyCallback(*window, key_callback);

	int gg = glewInit();
	char* hhh = (char*)glewGetErrorString(gg);
	fprintf(stdout, "ERROR: %s\n", hhh); // "No error"



	glfwGetFramebufferSize(*window, &width, &height);
	glViewport(0, 0, width, height);
	glClear(GL_COLOR_BUFFER_BIT);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	float m[] = {
	  1., 0., 0., 0.,
	  0., cos(alpha), sin(alpha), 0.,
	  0., -sin(alpha), cos(alpha), 0.0,
	  0., 0., 0., 1.f };
	glMultMatrixf(m);

#ifdef USESHADER
	programID = LoadShaders();
	printf("program id %i \n", programID);
#endif
	return;
}
